---
title: 'tRPC'
description: 'Creating type-safe APIs with tRPC in Orionjs'
---

Orionjs provides seamless integration with [tRPC](https://trpc.io/) for building end-to-end type-safe APIs. The `@orion-js/trpc` package offers decorators and utilities that work with Orionjs schemas and the service injection system.

## Installation

```bash
pnpm add @orion-js/trpc @trpc/server
```

## Key Features

- Full TypeScript type inference
- Integration with Orionjs schema validation
- Service injection support via `@Inject()`
- Compatible with the Orionjs component system

## Basic Setup

### 1. Create Procedures

Create a procedures class using the `@Procedures()` decorator:

```typescript
// app/exampleComponent/controllers/trpc/ExampleProcedures/index.ts
import {Procedures, TQuery, TMutation, createTQuery, createTMutation} from '@orion-js/trpc'
import {Inject} from '@orion-js/services'
import {ExampleSchema} from 'app/exampleComponent/schemas/ExampleSchema'
import {ExampleService} from 'app/exampleComponent/services/ExampleService'

@Procedures()
export class ExampleProcedures {
  @Inject(() => ExampleService)
  private exampleService: ExampleService

  @TQuery()
  getExample = createTQuery({
    params: {exampleId: {type: String}},
    returns: ExampleSchema,
    resolve: async ({exampleId}) => {
      return await this.exampleService.getExample(exampleId)
    },
  })

  @TQuery()
  listExamples = createTQuery({
    returns: [ExampleSchema],
    resolve: async () => {
      return await this.exampleService.getExamples()
    },
  })

  @TMutation()
  createExample = createTMutation({
    params: {name: {type: String}},
    returns: {message: {type: String}},
    resolve: async ({name}) => {
      await this.exampleService.createExample(name)
      return {message: 'Created successfully'}
    },
  })
}
```

### 2. Register in a Component

Add your procedure classes to a component's `trpc` controllers:

```typescript
// app/exampleComponent/index.ts
import {component} from '@orion-js/components'
import trpc from './controllers/trpc'

export default component({
  trpc,
  // ...other controllers
})
```

### 3. Start the tRPC Server

`startTRPC` accepts a `procedures` object (a `TRPCRouterRecord`) and builds the router internally:

```typescript
// app/config/trpc/index.ts
import {startTRPC} from '@orion-js/trpc'
import {logger} from '@orion-js/logger'
import type {TRPCRouterRecord} from '@trpc/server'

export default async function startTrpc<T extends TRPCRouterRecord>(procedures: T) {
  const {router} = await startTRPC({procedures, path: '/trpc'})
  logger.info('tRPC started at /trpc')
  return {router}
}
```

### 4. Wire Everything Together

The `component()` and `mergeComponents()` functions are generic, so tRPC procedure types flow through automatically:

```typescript
// app/config/index.ts
import {type Component, mergeComponents} from '@orion-js/components'

export async function startApp<T extends Component<any>[]>(components: [...T]) {
  const controllers = mergeComponents(components)
  // controllers.trpc is fully typed!
  const {router} = await startTrpc(controllers.trpc)
  return {router}
}
```

```typescript
// app/index.ts
import {startApp} from './config'
import exampleComponent from './exampleComponent'

const {router} = await startApp([exampleComponent])

// Export the router type for client usage
export type AppRouter = typeof router
```

## Decorators Reference

### @Procedures()

Marks a class as a tRPC procedures container. This decorator also applies `@Service()` for dependency injection.

```typescript
@Procedures()
export class MyProcedures {
  // procedures here
}
```

### @TQuery()

Marks a field as a tRPC query procedure.

```typescript
@TQuery()
myQuery = createTQuery({
  params: {...},
  returns: {...},
  resolve: async (params) => {...}
})
```

### @TMutation()

Marks a field as a tRPC mutation procedure.

```typescript
@TMutation()
myMutation = createTMutation({
  params: {...},
  returns: {...},
  resolve: async (params) => {...}
})
```

## Procedure Options

Both `createTQuery` and `createTMutation` accept the same options:

| Option | Type | Description |
|--------|------|-------------|
| `params` | Schema | Input validation schema (optional) |
| `returns` | Schema | Output schema for documentation (optional) |
| `resolve` | Function | The resolver function |

### Schema Types

You can use Orionjs schema definitions:

```typescript
// Inline schema
createTQuery({
  params: {
    userId: {type: String},
    includeDetails: {type: Boolean, optional: true}
  },
  returns: UserSchema,
  resolve: async ({userId, includeDetails}) => {...}
})

// Array returns
createTQuery({
  returns: [UserSchema],
  resolve: async () => {...}
})
```

## Merging Procedures

When using the component system, procedures are merged automatically via `mergeComponents()`. For standalone usage, you can use `mergeProcedures` to combine multiple procedure classes while preserving types:

```typescript
import {mergeProcedures} from '@orion-js/trpc'

// Supports up to 5 procedure classes with full type inference
const procedures = mergeProcedures([
  UserProcedures,
  PostProcedures,
  CommentProcedures,
])
```

## Server-Side Caller

Create a server-side caller for testing or internal use:

```typescript
const {router} = await startApp([exampleComponent])

const caller = router.createCaller({})

// Call procedures directly
const example = await caller.getExample({exampleId: '123'})
```

## startTRPC Options

```typescript
import {startTRPC} from '@orion-js/trpc'

await startTRPC({
  procedures,               // Required: TRPCRouterRecord (from components or mergeProcedures)
  path: '/trpc',            // Optional: endpoint path (default: '/trpc')
  bodyParserOptions: {      // Optional: body parser config
    limit: '10mb'
  }
})
```

## Context and Viewer

The tRPC context includes the Orionjs viewer:

```typescript
createTQuery({
  resolve: async (params, viewer) => {
    if (!viewer.user) {
      throw new Error('Unauthorized')
    }
    return await this.service.getData(viewer.user._id)
  }
})
```

## Error Handling

Throw errors normally - they'll be properly serialized by tRPC:

```typescript
import {TRPCError} from '@trpc/server'

createTMutation({
  resolve: async (params) => {
    const item = await this.repo.findOne(params.id)

    if (!item) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'Item not found'
      })
    }

    return item
  }
})
```

## File Organization

Recommended structure for tRPC procedures:

```
app/
└── exampleComponent/
    └── controllers/
        └── trpc/
            ├── ExampleProcedures/
            │   └── index.ts
            └── index.ts  # Exports procedure classes as array
```

The `controllers/trpc/index.ts`:

```typescript
import {ExampleProcedures} from './ExampleProcedures'

export default [ExampleProcedures]
```

## Paginated Queries

The `createTPaginatedQuery` function creates a query procedure designed for paginated tables. It provides a single endpoint with three actions: `getItems`, `getCount`, and `getDescription`.

### Basic Usage

```typescript
import {Procedures, TPaginatedQuery, createTPaginatedQuery} from '@orion-js/trpc'
import {Inject} from '@orion-js/services'
import {UsersRepo} from 'app/users/repos/UsersRepo'

@Procedures()
export class UserProcedures {
  @Inject(() => UsersRepo)
  private usersRepo: UsersRepo

  @TPaginatedQuery()
  listUsers = createTPaginatedQuery({
    params: {
      search: {type: String, optional: true},
    },
    allowedSorts: ['name', 'createdAt'],
    defaultSortBy: 'createdAt',
    defaultSortType: 'desc',
    getCursor: async ({search}, viewer) => {
      const query = search ? {name: {$regex: search, $options: 'i'}} : {}
      return this.usersRepo.find(query)
    },
    getCount: async ({search}, viewer) => {
      const query = search ? {name: {$regex: search, $options: 'i'}} : {}
      return this.usersRepo.countDocuments(query)
    },
  })
}
```

### Cursor Interface

The `getCursor` function must return a cursor-like object with the following methods:

```typescript
interface PaginatedCursor<TItem> {
  skip: (value: number) => void
  limit: (value: number) => void
  sort: (value: {[key: string]: 1 | -1}) => void
  toArray: () => Promise<TItem[]>
}
```

MongoDB cursors from Orionjs collections implement this interface automatically.

### Actions

The query accepts two arguments: `action` and `params`.

#### getItems

Returns the paginated items:

```typescript
const result = await caller.listUsers({
  action: 'getItems',
  params: {page: 1, limit: 10, sortBy: 'name', sortType: 'asc'},
})
// Returns: { items: User[] }
```

#### getCount

Returns the total count (for calculating total pages on the client):

```typescript
const result = await caller.listUsers({
  action: 'getCount',
  params: {search: 'john'},
})
// Returns: { totalCount: number }
```

#### getDescription

Returns the sorting configuration:

```typescript
const result = await caller.listUsers({
  action: 'getDescription',
  params: {},
})
// Returns: { allowedSorts: string[], defaultSortBy?: string, defaultSortType?: 'asc' | 'desc' }
```

### Options

| Option | Type | Description |
|--------|------|-------------|
| `params` | Schema | Custom input params schema (optional) |
| `returns` | Schema | Output item schema for cleaning (optional) |
| `getCursor` | Function | Returns a cursor with `skip`, `limit`, `sort`, `toArray` methods |
| `getCount` | Function | Returns the total count for the query |
| `allowedSorts` | string[] | List of allowed sort fields (optional) |
| `defaultSortBy` | string | Default sort field (optional) |
| `defaultSortType` | 'asc' \| 'desc' | Default sort direction (optional) |
| `defaultLimit` | number | Default page size (default: 20) |
| `maxLimit` | number | Maximum allowed page size (default: 200) |

### Built-in Params

The following params are automatically added and validated:

| Param | Type | Default | Description |
|-------|------|---------|-------------|
| `page` | integer | 1 | Page number (min: 1) |
| `limit` | integer | 20 | Items per page (min: 0, max: 200) |
| `sortBy` | string | - | Sort field (only if `allowedSorts` is configured) |
| `sortType` | 'asc' \| 'desc' | - | Sort direction |

### Type Inference

Item types are automatically inferred from the `getCursor` return type - no manual type annotations needed:

```typescript
interface User {
  id: string
  name: string
  email: string
}

@TPaginatedQuery()
listUsers = createTPaginatedQuery({
  getCursor: async () => {
    // Returns PaginatedCursor<User> - type is inferred automatically
    return this.usersRepo.find({})
  },
  getCount: async () => this.usersRepo.countDocuments({}),
})
```

### Schema Cleaning

If you provide a `returns` schema, items will be cleaned/filtered according to that schema:

```typescript
@TPaginatedQuery()
listUsers = createTPaginatedQuery({
  returns: {id: {type: 'ID'}, name: {type: String}},
  getCursor: async () => this.usersRepo.find({}),
  getCount: async () => this.usersRepo.countDocuments({}),
})
// Only 'id' and 'name' fields will be returned, extra fields are stripped
```

### Client Usage Example

```typescript
// In your paginated table component
const [page, setPage] = useState(1)
const [sortBy, setSortBy] = useState<string>()
const [sortType, setSortType] = useState<'asc' | 'desc'>()

// Fetch items
const {data: itemsData} = trpc.listUsers.useQuery({
  action: 'getItems',
  params: {page, limit: 10, sortBy, sortType},
})

// Fetch count for pagination
const {data: countData} = trpc.listUsers.useQuery({
  action: 'getCount',
  params: {},
})

// Fetch description for sort options
const {data: description} = trpc.listUsers.useQuery({
  action: 'getDescription',
  params: {},
})

const totalPages = Math.ceil((countData?.totalCount ?? 0) / 10)
```
