---
title: 'Introduction'
description: 'Creating type-safe APIs with tRPC in Orionjs'
---

Orionjs provides seamless integration with [tRPC](https://trpc.io/) for building end-to-end type-safe APIs. The `@orion-js/trpc` package offers decorators and utilities that work with Orionjs schemas and the service injection system.

## Installation

```bash
pnpm add @orion-js/trpc @trpc/server superjson
```

## Key Features

- Full TypeScript type inference
- Integration with Orionjs schema validation
- Service injection support via `@Inject()`
- Compatible with the Orionjs component system

## Basic Setup

### 1. Create Procedures

Create a procedures class using the `@Procedures()` decorator:

```typescript
// app/exampleComponent/controllers/trpc/ExampleProcedures/index.ts
import {Procedures, TQuery, TMutation, createTQuery, createTMutation} from '@orion-js/trpc'
import {Inject} from '@orion-js/services'
import {ExampleSchema} from 'app/exampleComponent/schemas/ExampleSchema'
import {ExampleService} from 'app/exampleComponent/services/ExampleService'

@Procedures()
export class ExampleProcedures {
  @Inject(() => ExampleService)
  private exampleService: ExampleService

  @TQuery()
  getExample = createTQuery({
    params: {exampleId: {type: String}},
    returns: ExampleSchema,
    resolve: async ({exampleId}) => {
      return await this.exampleService.getExample(exampleId)
    },
  })

  @TQuery()
  listExamples = createTQuery({
    returns: [ExampleSchema],
    resolve: async () => {
      return await this.exampleService.getExamples()
    },
  })

  @TMutation()
  createExample = createTMutation({
    params: {name: {type: String}},
    returns: {message: {type: String}},
    resolve: async ({name}) => {
      await this.exampleService.createExample(name)
      return {message: 'Created successfully'}
    },
  })
}
```

### 2. Register in a Component

Add your procedure classes to a component's `trpc` controllers:

```typescript
// app/exampleComponent/index.ts
import {component} from '@orion-js/components'
import trpc from './controllers/trpc'

export default component({
  trpc,
  // ...other controllers
})
```

### 3. Set Up the tRPC Server

You own the tRPC initialization directly. This gives you full control over transformer, error formatting, and middleware:

```typescript
// app/config/trpc/index.ts
import {initTRPC} from '@trpc/server'
import {createExpressMiddleware} from '@trpc/server/adapters/express'
import {createRoute, getApp, registerRoute} from '@orion-js/http'
import {defaultErrorFormatter} from '@orion-js/trpc'
import {logger} from '@orion-js/logger'
import type {TRPCRouterRecord} from '@trpc/server'
import superjson from 'superjson'

const t = initTRPC.create({
  transformer: superjson,
  errorFormatter: defaultErrorFormatter,
})

export default function startTrpc<T extends TRPCRouterRecord>(procedures: T) {
  const appRouter = t.router(procedures)

  const middleware = createExpressMiddleware({
    router: appRouter,
    createContext: ({req}) => ({
      viewer: (req as any)._viewer,
    }),
  })

  const app = getApp()
  const path = '/trpc'

  registerRoute(
    createRoute({
      app,
      method: 'all',
      path: `${path}/:trpcPath*`,
      bodyParser: 'json',
      async resolve(req, res, viewer) {
        ;(req as any)._viewer = viewer
        ;(req as any).url = req.url.replace(path, '')
        return middleware(req, res, () => {})
      },
    }),
  )

  logger.info('tRPC started at /trpc')

  return {router: appRouter}
}
```

Because you call `initTRPC.create()` directly, the router type naturally reflects your configuration (e.g. `transformer: true` when using superjson).

### 4. Wire Everything Together

The `component()` and `mergeComponents()` functions are generic, so tRPC procedure types flow through automatically:

```typescript
// app/config/index.ts
import {type Component, mergeComponents} from '@orion-js/components'

export async function startApp<T extends Component<any>[]>(components: [...T]) {
  const controllers = mergeComponents(components)
  // controllers.trpc is fully typed!
  const {router} = startTrpc(controllers.trpc)
  return {router}
}
```

```typescript
// app/index.ts
import {startApp} from './config'
import exampleComponent from './exampleComponent'

const {router} = await startApp([exampleComponent])

// Export the router type for client usage — transformer types flow through!
export type AppRouter = typeof router
```

## File Organization

Recommended structure for tRPC procedures:

```
app/
└── exampleComponent/
    └── controllers/
        └── trpc/
            ├── ExampleProcedures/
            │   └── index.ts
            └── index.ts  # Exports procedure classes as array
```

The `controllers/trpc/index.ts`:

```typescript
import {ExampleProcedures} from './ExampleProcedures'

export default [ExampleProcedures]
```
