---
description: Writing serverside code using the Orionjs Framework best practices
globs: *.ts
alwaysApply: false
---
You are a senior TypeScript programmer with experience in Orionjs framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with these basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using `any`.
  - Create necessary types when appropriate.
- Use JSDoc to document public classes and methods.
- Don't leave blank lines within a function.
- One export per file is preferred.

### Nomenclature

- Use PascalCase for classes and interfaces.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling. Except for standard abbreviations like API, URL, etc.


### Functions

- Write short functions with a single purpose. Aim for fewer than 20 instructions.
- Name functions with a verb and a noun.
  - If it returns a boolean, use isX, hasX, canX, etc.
  - If it doesn't return anything, use executeX, saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using objects.
  - Use an object to pass multiple parameters.
  - Use an object to return complex results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction within a function.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Use schema validation for data validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 lines of code.
  - Less than 10 public methods.
  - Less than 10 properties.
- Use dependency injection with the @Inject() decorator.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
  - Mock services using `mockService` from '@orion-js/services'.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to Orionjs

### Basic Principles

- Use component-based architecture.
- Encapsulate functionality in components.
  - One component per main domain.
  - Each component should contain:
    - Controllers for request handling
    - Schemas for data models
    - Services for business logic
    - Repositories for data access

### Project Structure

```
app/
├── config/           # Application configuration
├── componentName/    # Main component
│   ├── controllers/  # Controllers for different interfaces
│   │   ├── echoes/   # Event listeners
│   │   ├── routes/     # HTTP routes
│   │   ├── jobs/     # Background jobs
│   │   ├── modelResolvers/ # GraphQL model resolvers
│   │   └── resolvers/ # GraphQL resolvers
│   ├── repos/        # Data repositories
│   ├── schemas/      # Data schemas/models
│   ├── services/     # Business logic services
│   └── index.ts      # Component definition and exports
└── index.ts          # Application entry point
```

### Controllers

- Controllers are the entry points for code execution.
- Keep controllers thin - they should only:
  - Handle input validation
  - Call the appropriate services
  - Transform and return the response
- Different types of controllers:
  - HTTP controllers: Handle REST endpoints
  - GraphQL resolvers: Handle GraphQL operations
  - Job controllers: Handle scheduled or on-demand tasks
  - Echo controllers: Handle event-based communication

#### HTTP Controllers

```typescript
@Routes()
export default class ExampleRoutes {
  @Inject()
  private exampleService: ExampleService

  @Route({
    path: '/example/:id',
    method: 'get',
  })
  async getExample(req: Request): RouteResponse {
    const { id } = req.params
    return {
      body: await this.exampleService.getById(id),
    }
  }
}
```

#### GraphQL Resolvers

```typescript
@Resolvers()
export default class ExampleResolvers {
  @Inject()
  private exampleService: ExampleService

  @Query()
  @ResolverParams(ExampleParams)
  @ResolverReturns(ExampleSchema)
  async example(params: ExampleParams): Promise<ExampleSchema> {
    return await this.exampleService.getById(params.id)
  }

  @Mutation()
  @ResolverReturns(String)
  async createExample(): Promise<string> {
    await this.exampleService.create()
    return 'Created example'
  }
}
```

### Services

- Services contain the business logic.
- Use dependency injection with the @Inject() decorator.
- Services should be testable with clear dependencies.

```typescript
@Service()
export class ExampleService {
  @Inject()
  private exampleRepository: ExampleRepository

  async getById(id: string): Promise<ExampleSchema> {
    return await this.exampleRepository.findById(id)
  }
  
  async create(data: CreateExampleInput): Promise<string> {
    return await this.exampleRepository.insert(data)
  }
}
```

### Repositories

- Repositories handle data access logic.
- Use MongoDB repositories with @MongoCollection.
- Encapsulate database operations within repositories.

```typescript
@Repository()
export class ExampleRepository {
  @MongoCollection({
    name: 'examples',
    model: ExampleSchema,
    indexes: [
      {
        keys: {
          name: 1,
        },
      },
    ],
  })
  private collection: Collection<ExampleSchema>

  async findById(id: string): Promise<ExampleSchema> {
    return await this.collection.findOne({ _id: id })
  }
  
  async insert(data: Partial<ExampleSchema>): Promise<string> {
    return await this.collection.insertOne({
      ...data,
      createdAt: new Date()
    })
  }
}
```

### Schemas

- Use @TypedSchema() to define schemas.
- Use @Prop() for properties with proper typing.
- Define enums with createEnum.

```typescript
export const ExampleTypeEnum = createEnum('ExampleTypeEnum', [
  'type1',
  'type2',
  'type3',
] as const)

@TypedSchema()
export class ExampleSchema {
  @Prop()
  _id: string

  @Prop()
  name: string

  @Prop()
  createdAt: Date

  @Prop({ optional: true, type: ExampleTypeEnum })
  type?: typeof ExampleTypeEnum.type
}
```

### Testing

- Use Jest for testing.
- Mock services in unit tests.
- Test controllers by verifying they call the right services.
- Test services by mocking repositories.

```typescript
// In your test
import { mockService } from '@orion-js/services'
import { ExampleRepository } from './ExampleRepository'
import { ExampleService } from './ExampleService'

describe('ExampleService', () => {
  it('should retrieve an example by id', async () => {
    // Mock the repository
    mockService(ExampleRepository, {
      findById: async () => ({
        _id: '123',
        name: 'Test Example',
        createdAt: new Date()
      })
    })

    const service = new ExampleService()
    const result = await service.getById('123')
    
    expect(result).toBeDefined()
    expect(result._id).toBe('123')
  })
})
```

### Components

- Register all controllers in the component definition.
- Export the component to be used in the application.

```typescript
export default component({
  echoes,
  routes,
  jobs,
  modelResolvers,
  resolvers,
})
```

### Error Handling

- Use appropriate HTTP status codes for REST errors.
- Prefer using the `UserError` class for custom errors or `ValidationError` for validation errors.
- Log errors using the `logger` package.