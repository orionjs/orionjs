---
description: How to create a good Orionjs Repository
globs: *.ts
alwaysApply: true
---
# How to create a good Repository

## Repository Pattern

Repositories in Orionjs handle data access operations, separating data access logic from business logic. They should focus exclusively on database interactions.

When asked to create a new repository, create a minimal repository, with the basic CRUD operations and no indexes.

## Structure
- Use `@Repository()` decorator from `@orion-js/mongodb`
- Each repository should manage a single entity type
- Follow clear naming conventions: `{EntityNameInPlural}Repo`
- Methods should be atomic and focused on CRUD operations

## Best Practices
- Keep methods simple and focused on a single responsibility
- **Never access the collection directly outside the repository.** All database interactions must go through repository methods. The only exception is during migrations, where direct collection access may be necessary for data transformations.
- If you need to create a new query or a new method, always do it inside the repository file.
- Collection name should be `component_name.prural_of_entity`. Component name is the name of the folder of the component.
- Return plain objects or domain models, not database-specific structures
- Use descriptive method names: `findById`, `findByEmail`, `create{EntityName}`, `update{EntityName}`, `delete{EntityName}`.
- **NEW RULE**: Use `load` prefix instead of `get` for methods where data freshness is not guaranteed. See "Naming Convention: get vs load" section below.
- Avoid business logic in repositories (use services instead)
- Add proper typing for all parameters and return values.
- Put the repository in `app/exampleComponent/repos/{EntityNameInPlural}Repo/index.ts`
- Always use `typedId()` in schema definitions for document IDs
- Use `InferSchemaType` to derive types from schemas
- IMPORTANT NEW RULE: Use read preferences for non-critical queries.

## Read Preferences for Non-Critical Queries

For queries that don't require strong consistency (eventually consistent reads), use the `preferSecondary` option to distribute read load across MongoDB replica set secondaries. This is especially important for:

- **Aggregations**: Heavy aggregation pipelines should prefer secondary reads
- **List queries**: Paginated lists or search results
- **Reports and analytics**: Any read-heavy operations for dashboards or statistics
- **Count operations**: Document counts for UI display

### Naming Convention: get vs load

> **⚠️ NEW RULE**: Use the **"load"** prefix instead of **"get"** for methods where data freshness is not guaranteed. The `load` prefix signals to consumers that the returned data may not reflect the most recent state of the database.
>
> **Migration Note**: Existing code in the project might still use "get" prefix for these methods. When you encounter methods that should use "load" based on the criteria below, suggest renaming them for consistency.

**Use `load` prefix when the method:**
- Uses `secondaryPreferred` read preference (eventually consistent reads from replica secondaries)
- Uses DataLoader methods like `loadById`, `loadMany` (batched/deduplicated reads within request scope)
- Reads from cache (in-memory, Redis, or any caching layer)

**Use `get` prefix when the method:**
- Reads directly from primary with no caching
- Requires guaranteed data freshness (read-after-write scenarios)

**Examples:**
- `getCardsListCursor` → `loadCardsListCursor` (uses `secondaryPreferred`)
- `getCardsListCount` → `loadCardsListCount` (uses `secondaryPreferred`)
- `getCardById` → `loadCardById` (if using DataLoader or cache)
- `getUserStats` → `loadUserStats` (if using cache or aggregation on secondary)

Use `preferSecondary` by passing the option to collection methods:

```typescript
// "load" prefix: uses secondaryPreferred (data may be slightly stale)
async loadCardsListCursor(params: CardsListQueryParamsType) {
  const query = await this.getCardsListQuery(params)
  return this.collection.find(query, {readPreference: 'secondaryPreferred'})
}

// "load" prefix: uses secondaryPreferred
async loadCardsListCount(params: CardsListQueryParamsType) {
  const query = await this.getCardsListQuery(params)
  return this.collection.countDocuments(query, {readPreference: 'secondaryPreferred'})
}

// "load" prefix: aggregation on secondary
async loadCardsStats() {
  return this.collection.aggregate([
    {$group: {_id: '$type', count: {$sum: 1}}}
  ], {readPreference: 'secondaryPreferred'})
}

// "load" prefix: uses DataLoader (batched/deduplicated within request)
async loadCardById(cardId: CardId) {
  return this.collection.loadById(cardId)
}
```

**When NOT to use `preferSecondary`:**
- When reading data immediately after a write (use primary for read-after-write consistency)
- For critical operations where stale data could cause issues
- When the query result will be used to make a write decision

## Example

In this example we have a `Card` entity and a `CardsRepo` repository.

```typescript
import {createCollection, MongoFilter, Repository, OptionalId, MongoDB} from '@orion-js/mongodb'
import {InferSchemaType} from '@orion-js/schema'
import {CardSchema, Card, CardId} from '../schemas/Card'
import {CardsListQueryParamsType} from './ListQueryParams'

@Repository()
export class CardsRepo {
  // Collection is public only to allow access during migrations.
  // Never access this collection directly outside this repository.
  collection = createCollection({
    name: 'gaming.pokemon_cards',
    schema: CardSchema,
    indexes: [],
  })


  async createCard(doc: OptionalId<Card>) {
    return await this.collection.insertAndFind(doc)
  }

  // "get" prefix: direct read from primary, guaranteed fresh data
  async getCardById(docId: CardId) {
    return await this.collection.findOne(docId)
  }

  // "load" prefix: uses DataLoader (batched/deduplicated, may return cached data within request)
  async loadCardById(docId: CardId) {
    return await this.collection.loadById(docId)
  }

  async updateCard(docId: CardId, doc: MongoDB.UpdateFilter<Card>['$set']) {
    return await this.collection.updateAndFind(docId, {$set: doc})
  }

  async deleteCard(docId: CardId) {
    await this.collection.updateOne(docId, {$set: {deletedAt: new Date()}})
  }

  private async getCardsListQuery(params: CardsListQueryParamsType) {
    const queries: MongoFilter<Card>[] = []

    return {
      $and: queries,
    }
  }

  // "load" prefix: uses secondaryPreferred (data may be slightly stale)
  async loadCardsListCursor(params: CardsListQueryParamsType) {
    const query = await this.getCardsListQuery(params)
    return this.collection.find(query, {readPreference: 'secondaryPreferred'})
  }

  // "load" prefix: uses secondaryPreferred
  async loadCardsListCount(params: CardsListQueryParamsType) {
    const query = await this.getCardsListQuery(params)
    return this.collection.countDocuments(query, {readPreference: 'secondaryPreferred'})
  }
}

// at ListQueryParams.ts
import {schemaWithName, InferSchemaType} from '@orion-js/schema'

export const CardsListQueryParamsSchema = schemaWithName('CardsListQueryParams', {
  filter: {type: String, optional: true},
})

export type CardsListQueryParamsType = InferSchemaType<typeof CardsListQueryParamsSchema>
```

For this example, this could be the schema. Note the `_id` property uses `typedId` for automatic ID prefixing.

```typescript 
import {schemaWithName, InferSchemaType, typedId} from '@orion-js/schema'

export const typedCardId = typedId('crd')
export type CardId = typeof typedCardId.__tsFieldType

export const CardSchema = schemaWithName('Card', {
  _id: {type: typedCardId},
  name: {type: String},
  // ... other properties
})

export type Card = InferSchemaType<typeof CardSchema>

// The type will be inferred as:
// type Card = {
//   _id: `crd-${string}`;
//   name: string;
//   ...
// }
```

## Integration with Services

Services should inject repositories for data access:

```typescript
import {Service, Inject} from '@orion-js/services'
import {UserRepository} from '../repos/UsersRepo'
import {UserId} from '../schemas/User'

@Service()
export class UserService {
  @Inject(() => UserRepository)
  private userRepository: UserRepository
  
  async getUserDetails(userId: UserId) {
    const user = await this.userRepository.findById(userId)
    // Process user data with business logic
    return processedUserData
  }
}
```
